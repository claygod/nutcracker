# nutcracker

[![API documentation](https://godoc.org/github.com/claygod/nutcracker?status.svg)](https://godoc.org/github.com/claygod/nutcracker)

Problem-based approach

## Задачный подход

Решатель, который может искать цепочку возможных шагов для того чтобы приблизиться из стартового состояния к целевому.
Проблема постановки задачи остаётся "снаружи".

## Процесс

Создаём решатель, учим каким-то базовым, хардкорным умениям и затем ставим задачи и смотрим что получится. 
Если в процессе решения задачи будет найден какой-то весьма эффективный ход (цепочка ходов), то этот ход может быть добавлен к базовым.

Решатель ищет множество решений, и из этого пула решений какое-то будет выбрано исходя из неких критериев.
Если решения не найдены, то предусмотрен вариант с поиском случайного хода, после которого можно будет найти решение, т.е. поиск кружного пути.
(Пока это метод через простое увеличение числа шагов в цепочке)

### Обучение

Базовые чейнжеры тоже можно генерировать не как определенные математические функции, 
а на примере, когда есть входное и выходное состояние и внутренняя функция, этоприменение дельты между ними

## ToDo

- [*] имплементация CalcChainletRate (нужна хоть какая-нибудь, базовая)
- [*] имплементация AtomicChanger
- [*] имплементация AtomicChangerRepository
- [*] имплементация StateComparer (возможно снаружи передается при начальном создании)
- [ ] имплементация ProblemWithAnswer
- [ ] имплементация ProblemWithAnswerRepo
- [*] имплементация ChainletGenerator
- [ ] продумать тему колонок, это что-то вроде групп чейнджеров, объединенных по принципу например близости входов, целей, или дельт
- [ ] нужно уметь начинать работать без внешних целей и учиться их ставить
- [ ] результат работы мозга в моменте - это прогноз вероятного будущего и предложения по следующему шагу
- [ ] формируемые цели могут быть как позитивными (к ним) так и негативными (от них)
- [ ] виртуализация - создание модели мира и прокручивание на ней вариантов
- [ ] наблюдение за другими - это сродни виртуализации, формирование модели и обучение на примерах отрицательных и положительных целей
- [ ] история - цепочка State (возможна "тень" как след, указывающий на изменение)
- [ ] вычленение объектов в State


## Визуализация пакета

- устанавливаем https://github.com/davidschlachter/embedded-struct-visualizer/tree/main
- в корне нужного пакета запускаем embedded-struct-visualizer -out sh.txt ./
- на https://dreampuf.github.io/GraphvizOnline/ визуализируем полученный текстовый файл

# Copyright

Copyright © 2022-2024 Eduard Sesigin. All rights reserved. Contacts: claygod@yandex.ru
